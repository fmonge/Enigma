;macro cifrado
;	rotores, refector
;	plugboard
; %include "string.mac"	

%macro rotoresM 2
        push rbx
        push rcx;!!!!!!1
	push rax
	push r8
	push r9
	xor r9, r9
	mov rcx, %2
  	xor rbx, rbx
%%loop:
	xor rax, rax
	mov al, byte [textoCifrado + rbx ] ; rdx =  buf mas desplazamiento
        sub al, 'A'             ;obtener pos en rotor next      
	mov ah, byte [%1+ rax]
	mov al, ah              ; en al para stosb
        stosb                   ; al a [rdi++]
        ;rotar %1, %2           ; macro rotar
     	;cmp rcx, 1
	rotarM %2

        inc rbx
        cmp rbx, r8
        jne %%loop
;	je %%fin
;	%%fin:

	pop r9
	pop r8
	pop rax
        pop rcx
        pop rbx

;        xor rbx, rbx
        ;ret
%endmacro


%macro rotarM 1
;	push rcx
	mov rcx, %1
	cmp rcx, 1
	je %%uno
	cmp rcx, 2
	je %%dos
	cmp rcx, 3
	je %%tres
	jne %%fin

%%uno:
	rotarBuf rotorUno, 1
	jmp %%fin	
%%dos:
	inc r9
	cmp r9, 27
	jne %%fin
	rotarBuf rotorDos, 1
	jmp %%fin
%%tres:
	inc r9
	cmp r9, 676
	jne %%fin
	rotarBuf rotorDos, 1
%%fin:
;	pop rcx
%endmacro



;****************************************
%macro plugboardM 2             ; lenBuf, plugboard
        push rax                ;XF,PZ,SQ,GR,AJ,UO,CN,BV,TM,KI  
        push rcx        ; cont Buf
        push rbx        ; cont de pb
        push rdx

        xor rcx, rcx
%%loopBuf:
        xor rbx, rbx
        xor rax, rax
        ;div rbx, divide el rax entre el rbx, 
        ;deja el resultado en el rax y el residuo en el rdx     
        mov al, [textoCifrado+ rcx]

%%loopPb:
        mov ah, [%2+ rbx]
        cmp al, ah
        je %%swap

        inc rbx
        cmp rbx, 29
        jne %%loopPb
        je %%continueLoop
%%swap:
        cmp rbx, 0
        je %%masUno
        cmp rbx, 1
        je %%menosUno
        cmp rbx, 28
        je %%menosUno
        cmp byte [%2+ rbx - 1], ','
        je %%masUno
        jne %%menosUno

%%masUno:               ;no dec rdi     
        mov ah, [%2 + rbx + 1 ]
        mov [textoCifrado + rcx], ah
        jmp %%continueLoop

%%menosUno:
        mov ah, [%2 + rbx - 1]
        mov byte[textoCifrado + rcx], ah

%%continueLoop:
        inc rcx
        cmp rcx, %1
        jne %%loopBuf
%%endPB
        pop rdx
        pop rbx
        pop rcx
        pop rax
%endmacro
;**********************************



;**********************************
%macro NOrotarBuf 2; buffer (deTama√±o rcx) , cantidad de rotaciones
	push rcx
	push r8
	push rdi
	push rsi

	mov r8, rcx
	movBuf bufTmp, %1
	sub rcx, %2
	lea rsi, [bufTmp + %2]	
	lea rdi, [%1]
	rep movsb
	lea rdi, [%1]
	lea rsi, [bufTmp]
	xor rcx, rcx
	mov rcx, %2
	rep movsb
	

	pop rsi
	pop rdi
	pop r8
	pop rcx
%endmacro
