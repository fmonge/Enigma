;macro cifrado
;	rotores, refector
;	plugboard
	

%macro rotoresM 1
        push rbx
        push rcx
	push rax
  	xor rbx, rbx
%%loop:
	xor rax, rax
	mov al, byte [textoCifrado + rbx ] ; rdx =  buf mas desplazamiento
        sub al, 'A'             ;obtener pos en rotor next      
	mov ah, byte [%1+ rax]
	mov al, ah              ; en al para stosb
        stosb                   ; al a [rdi++]
        ;rotar %1, %2           ; macro rotar
        ;pop rax
	; rotor %1, rbx   ; %macro rotor 1  ; rotorActual
        inc rbx
        cmp rbx, r8
        jne %%loop

	pop rax
        pop rcx
        pop rbx
        xor rbx, rbx
        ;ret
%endmacro

%macro plugboardM 2             ; lenBuf, plugboard
        push rax                ;XF,PZ,SQ,GR,AJ,UO,CN,BV,TM,KI  
        push rcx        ; cont Buf
        push rbx        ; cont de pb
        push rdx

        xor rcx, rcx
%%loopBuf:
        xor rbx, rbx
        xor rax, rax
        ;div rbx, divide el rax entre el rbx, 
        ;deja el resultado en el rax y el residuo en el rdx     
        mov al, [textoCifrado+ rcx]

%%loopPb:
        mov ah, [%2+ rbx]
        cmp al, ah
        je %%swap

        inc rbx
        cmp rbx, 29
        jne %%loopPb
        je %%continueLoop

%%swap:
        cmp rbx, 0
        je %%masUno
        cmp rbx, 1
        je %%menosUno
        cmp rbx, 28
        je %%menosUno
        cmp byte [%2+ rbx - 1], ','
        je %%masUno
        jne %%menosUno

%%masUno:               ;no dec rdi     
        mov ah, [%2 + rbx + 1 ]
        mov [textoCifrado + rcx], ah
        jmp %%continueLoop

%%menosUno:
        mov ah, [%2 + rbx - 1]
        mov byte[textoCifrado + rcx], ah

%%continueLoop:
        inc rcx
        cmp rcx, %1
        jne %%loopBuf
%%endPB
        pop rdx
        pop rbx
        pop rcx
        pop rax
%endmacro


